# 3️⃣0️⃣ Item 30: 이왕이면 제네릭 메서드로 만들라

<br>

## 📌 목차
1. 제네릭 메서드
2. 일반 메서드 → 제네릭 메서드
3. 항등 함수 → 제네릭 메서드
4. Comparable과 함께 쓰이는 메서드 → 제네릭 메서드
5. 결론

<br>

## 📥 제네릭 메서드

클래스와 마찬가지로 `메서드도 제네릭`으로 만들 수 있다. 

매개변수화 타입을 받는 정적 유틸리티 메서드는 보통 제네릭이다. 

예를 들어 Collections의 알고리즘 메서드 = binarySearch, sort 메서드 등은 모두 제너릭이다. 

아래 코드는 Collections의 sort 메서드이다.

`제네릭 타입을 사용하는 제네릭 메서드`임을 볼 수 있다. 

```java
    public static <T extends Comparable<? super T>> void sort(List<T> list) {
        list.sort(null);
    }
```

<br>

이렇게` 메서드도 이왕이면 제네릭 메서드로 만들어서 사용`하자는 것이 이번 item이 말하고자 하는 것이다. 

이제 `아래의 메서드들을 제네릭 메서드로` 바꾸는 방법을 보자. 

- 일반 메서드

- 항등 함수

- Comparable과 함께 쓰이는 메서드

<br>

## 🔁 일반 메서드 → 제네릭 메서드

### 🚫 문제 있는 일반 메서드

먼저 두 집합의 합집합을 반환하는 `문제 있는 메서드 union 메서드`를 보자. 

```java
    public static Set union(Set s1, Set s2) {
        Set result = new HashSet(s1);
        result.addAll(s2);
        return result;
    }
```

<br>

이 메서드에서는 `로 타입을 사용하고 있어 문제`가 된다. 

이 메서드를 사용하려고 하면 `컴파일은 되지만 경고가 발생`한다. 

경고가 발생한 이유는 아래와 같다. 

- 로 타입을 사용해 `타입 안정성이 보장되지 않기 때문`이다.

- 로 타입을 사용해 `실행 시간에 예상치 못한 ClassCastException과 같은 문제가 발생할 수 있기 때문`이다.

```java
Unchecked call to 'HashSet(Collection<? extends E>)' as a member of raw type 'java.util.HashSet' 

Unchecked call to 'addAll(Collection<? extends E>)' as a member of raw type 'java.util.Set' 
```

<br>

### ⚒ 문제 있는 일반 메서드 수정

경고를 없애려면 이 메서드를 타입 안전하게 만들어야 한다. 

`로 타입을 사용하던 곳을 제네릭 타입으로 변경`하면 된다. 

변경해야 하는 곳은 다음과 같다. 

- 메서드 선언의 반환 타입
- 메서드 선언의 파라미터 타입
- 메서드 내부

<br>

이곳들의 `Set의 원소 타입을 타입 매개변수로 명시`하면 된다. 

타입 매개변수 명시하면 아래와 같이 된다. 

```java
    public static Set<E> union(Set<E> s1, Set<E> s2) {
        Set<E> result = new HashSet(s1);
        result.addAll(s2);
        return result;
    }
```

<br>

그 후 메서드의 제한자와 반환 타입 사이에 `타입 매개변수를 선언`하면 된다. 

```java
public static Set<E> union(Set<E> s1, Set<E> s2){...}
->
public static <E> Set<E> union(Set<E> s1, Set<E> s2){...}
```

<br>

여기에서 타입 매개변수가 < E >이고 반환 타입이 Set< E >인 것이다. 

>왜 이렇게 하는가 하면 위처럼 메서드를 선언하면 `컴파일러는 E라는 타입 매개변수가 어디에서 선언되었는지 알 수 없다`. 
>
>E가 메서드의 로컬 타입 매개변수로 선언되지 않았기 때문에 발생하는 것이다. 
>
>Java에서 `메서드에 제네릭 타입을 사용하려면, 반드시 메서드의 반환 타입 앞에 타입 매개변수를 선언`해야 한다. 

단순한 제네릭 메서드라면 이 정도로 하면 충분하다. 

<br>

이렇게 제네릭 메서드로 변경하면 다음과 같은 `장점`을 얻게 된다. 

- 경고 없이 컴파일 된다.
- 타입 안전하다.
- 쓰기 쉽다.

<br>

이렇게 변경한 제네릭 메서드는 아래와 같다.

```java
    public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
        Set<E> result = new HashSet<>(s1);
        result.addAll(s2);
        return result;
    }
```

<br>

## 🔂 항등 함수 → 제네릭 메서드

### 👥 항등 함수

프로그래밍에서 항등 함수는 `입력된 값이 그대로 출력되는 함수`를 말한다. 

즉, 항등 함수는 받은 인자를 그대로 반환하는 가장 간단한 형태의 함수다.

<br>

### 🧑‍🤝‍🧑 항등함수 객체

이런 `항등함수를 담은 클래스`가 있다.

이런 클래스를 인스턴스화 한 것을 항등함수 객체라고 한다. 

항등함수 객체는 함수의 동작을 모델링하는 객체를 나타내는 데 사용될 수 있다. 

이 `객체는 항등 함수의 동작을 구현한 것`으로, 입력된 값을 그대로 반환하는 메서드 = 항등함수를 가진다.

이런 객체는 다양한 프로그래밍 언어와 라이브러리에서 찾아볼 수 있다.

항등함수 객체는 자주 사용되는 `함수적 인터페이스나 람다 표현식의 형태로 제공`된다.

<br>

### 🏭 제네릭 싱글턴 팩터리

이런 항등함수 객체는 `상태가 없으니 요청할 때마다 새로 생성하는 것은 낭비`다. 

또한 항등함수 객체는 상태가 없고 동일한 입력에 대해 동일한 결과를 반환해 `불변 객체라고 볼 수 있다`. 

때때로 이런 `불변 객체를 여러 타입으로 활용할 수 있게` 만들어야 할 때가 있다. 

이럴 때 제네릭이 없다면 **`항등함수를 타입별로 하나씩`** 만들어야 한다. 

하지만 제네릭은 런타임에 타입 정보가 소거되므로 하나의 객체를 어떤 타입으로든 매개변수화 할 수 있다.

<br>

이렇게 하려면 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 `정적 팩터리`를 만들어야 한다. 

이 패턴을 `제네릭 싱글턴 팩터리 패턴`이라고 한다. 

이렇게 제네릭에서 타입 정보가 소거되어서 `항등함수를 타입별로 하나씩 만들지 않고 제네릭 싱글턴 팩터리 하나로 할 수 있는 것`이다. 

<br>

따라서 이렇게 ***`항등함수를 제네릭 싱글턴 팩터리 메서드로 만들어서 사용`*** 하자는 것이다. 

<br>

### ⚡ 제네릭 싱글턴 팩터리 예시

제네릭 싱글턴 팩터리를 사용하는 예시를 보자. 

```java
    // 코드 30-4 제네릭 싱글턴 팩터리 패턴 (178쪽)
    private static UnaryOperator<Object> IDENTITY_FN = (t) -> t;

    @SuppressWarnings("unchecked")
    public static <T> UnaryOperator<T> identityFunction() {
        return (UnaryOperator<T>) IDENTITY_FN;
    }
```

<br>

IDENTITY_FN을 UnaryOperator< T >로 형변환하면 비검사 형변환 경고가 발생한다. 

T가 어떤 타입이든 `UnaryOperator< Object >는 UnaryOperator< T >가 아니기 때문`이다. 

<br>

>하지만 항등함수는 입력 값을 수정 없이 그대로 반환하는 특별한 함수이다. 
>
>따라서 `T가 어떤 타입이든 UnaryOperator< T >를 사용해도 타입 안전`하다. 
>
>왜냐하면 IDENTITY_FN를 UnaryOperator< Object > 타입으로 선언했으니 이 `객체가 모든 타입의 객체를 입력으로 받아 그대로 반환할 수 있다`.
>
>즉 이 함수가 `어떤 타입의 입력에 대해서도 올바르게 작동`한다는 것을 의미한다. 
>
>이런 특성 때문에, IDENTITY_FN을 다른 타입 매개변수를 갖는 `UnaryOperator< T >로 형변환해도 안전`한 것이다. 

<br>

이러한 사실 때문에 이 메서드가 내보내는 `비검사 형변환 경고는 숨겨도 안심`할 수 있다. 

따라서 `@SuppressWarnings`를 추가하고 이렇게 하면 오류나 경고 없이 컴파일된다. 

<br>

## ♻ Comparable과 함께 쓰이는 메서드 → 제네릭 메서드

`Comparable과 함께 쓰이는 메서드에는 재귀적 타입 한정이라는 개념이 사용`된다. 

재귀적 타입 한정이 무엇인가 하면 `자기 자신이 들어간 표현식을 사용해 타입 매개변수의 허용 범위를 한정하는 것`이다. 

재귀적 타입 한정은 주로 타입의 자연적 순서를 정하는 `Comparable 인터페이스와 함께 쓰인다`. 

<br>

무슨 말인지 잘 모르겠으니 예시를 보며 알아보자. 

<br>

### ❇ 예시

먼저 Comparable 인터페이스를 보자. 

```java
public interface Comparable<T>{
		int compareTo(T o);
}
```

<br>

여기서 타입 매개변수 T는 Comparable 인터페이스를 구현한 타입이 비교할 수 있는 원소의 타입을 정의하는 것이다. 

즉 `Comparable< T > 인터페이스를 구현한 클래스는 T 타입과 비교할 수 있다는 것`이다. 

실제로 `거의 모든 타입은 자신과 같은 타입의 원소와만 비교할 수 있다`. 

그래서 String은 Comparable< String >을, Integer는 Comparable< Integer >를 구현한 것이다. 

<br>

### 🗑 ‘Comparable 구현 객체 담은 컬렉션’ 파라미터로 받는 메서드

Comparable 인터페이스를 구현한 클래스가 있다. 

이 클래스의 객체들을 담고 있는 컬렉션이 있다. 

이 컬렉션을 입력받는 메서드들은 주로 그 객체들에 대해 다음과 같은 일을 한다. 

- 컬렉션 안의 객체 정렬
- 컬렉션 안의 객체 검색
- 컬렉션 안의 객체 최대, 최소 값 찾기

<br>

이런 기능을 수행하려면 `컬렉션에 담긴 모든 원소가 상호 비교될 수 있어야 한다`. 

따라서 `메서드의 타입 매개변수를 선언하는 곳에 재귀적 타입 한정`을 쓰는 것이다. 

아래처럼 코드를 작성하는 것이다. 

```java
public static <E extends Comparable<E>> E max(Collection<E> c){
		...
}
``` 

<br>

>재귀적 타입 한정은 `< E extends Comparable< E >>` 인 것이다. 
>
>이것은 “모든 타입 E는 자신과 비교할 수 있다”는 의미이다. 
>
>`컬렉션에 담긴 모든 원소가 상호 비교될 수 있다는 뜻`을 정확하게 표현하고 있는 것이다. 
>
>이 메서드에서 사용하는 `타입 매개변수 E는 Comparable 인터페이스를 구현`해야 한다는 것이다. 
>
>여기서` E는 타입 매개변수`이고 `extends Comparable< E >는 제약 조건`이다. 
>
>E로 지정된 타입은 `반드시 Comparable 인터페이스를 구현해 E 타입의 인스턴스끼리 서로 비교될 수 있어야 한다는 의미`이다. 

<br>

앞에서 재귀적 타입 한정은 자기 자신이 들어간 표현식을 사용해 타입 매개변수의 허용 범위를 한정할 수 있다고 했다. 

이렇게 `타입 매개변수 E에 제약 조건을 줘 범위를 한정`하는 것이다. 

이렇게 `한정해서 컬렉션에 담긴 모든 원소가 상호 비교`될 수 있게 한 것이다. 

<br>

따라서 `Comparable 인터페이스와 함께 쓰이는 메서드는 제너릭을 사용할 때 재귀적 타입 한정을 사용`하자는 것이다. 

<br>

## ‼ 결론

클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 `제네릭 메서드가 더 안전하며 사용하기 쉽다`. 

메서드도 형변환 없이 사용할 수 있는 편이 좋다. 

메서드에서 `형변환하는 것이 많은 경우 제네릭 메서드`가 되어야 한다. 

`형변환을 해줘야 하는 기존 메서드는 제네릭 메서드로` 만들자. 

이렇게 하면 `기존 클라이언트는 그대로 둔 채 새로운 사용자의 삶을 훨씬 편하게 만들어줄 것`이다.